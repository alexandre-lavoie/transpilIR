const std = @import("std");

const common = @import("../common.zig");

pub const Token = struct {
    token_type: TokenType,
    span: common.SourceSpan = common.SourceSpan{},

    const Self = @This();

    pub fn init(token_type: TokenType) Self {
        return Self{ .token_type = token_type };
    }
};

pub const TokenReader = struct {
    collection: Collection,
    offset: usize = 0,

    const Self = @This();
    const Collection = []const Token;

    pub fn init(collection: Collection) Self {
        return Self{ .collection = collection };
    }

    pub fn readToken(self: *Self) *const Token {
        if (self.offset >= self.collection.len) return &self.collection[self.collection.len - 1];

        const index = self.offset;
        self.offset += 1;

        return &self.collection[index];
    }
};

pub const TokenType = enum(u8) {
    // Module
    module_start,
    module_end,

    // Identifiers
    global_identifier,
    label_identifier,
    local_identifier,
    type_identifier,

    // Literals
    string_literal,
    single_literal,
    double_literal,
    integer_literal,

    // Punctuations
    comma,
    open_parenthesis,
    close_parenthesis,
    open_curly_brace,
    close_curly_brace,
    variable_arguments,
    plus,
    assign,

    // Reserved Words
    byte_unsigned,
    byte,
    common,
    data,
    debug_file,
    debug_location,
    double,
    env,
    @"export",
    function,
    long,
    section,
    single,
    thread,
    type,
    word_unsigned,
    word,
    zero,

    // Operations
    addition,
    @"align",
    allocate,
    any_load,
    arthimetic_shift_right,
    bitwise_and,
    bitwise_or,
    bitwise_xor,
    blit,
    byte_load_unsigned,
    byte_load,
    byte_store,
    byte_to_integer_unsigned,
    byte_to_integer,
    call,
    cast,
    copy,
    divide_unsigned,
    divide,
    double_all_nan,
    double_any_nan,
    double_equal,
    double_greater_than_equal,
    double_greater_than,
    double_less_than_equal,
    double_less_than,
    double_load,
    double_not_equal,
    double_store,
    double_to_single,
    double_to_integer_unsigned,
    double_to_integer,
    half_word_load_unsigned,
    half_word_load,
    half_word_store,
    half_word_to_integer_unsigned,
    half_word_to_integer,
    half_word_unsigned,
    half_word,
    halt,
    jump_not_zero,
    jump,
    long_equal,
    long_greater_than_equal_unsigned,
    long_greater_than_equal,
    long_greater_than_unsigned,
    long_greater_than,
    long_less_than_equal_unsigned,
    long_less_than_equal,
    long_less_than_unsigned,
    long_less_than,
    long_load,
    long_not_equal,
    long_store,
    long_to_float_unsigned,
    long_to_float,
    multiply,
    negate,
    phi,
    remainder_unsigned,
    remainder,
    @"return",
    shift_left,
    shift_right,
    single_all_nan,
    single_any_nan,
    single_equal,
    single_greater_than_equal,
    single_greater_than,
    single_less_than_equal,
    single_less_than,
    single_load,
    single_not_equal,
    single_store,
    single_to_double,
    single_to_integer_unsigned,
    single_to_integer,
    subtract,
    vaarg,
    vastart,
    word_equal,
    word_greater_than_equal_unsigned,
    word_greater_than_equal,
    word_greater_than_unsigned,
    word_greater_than,
    word_less_than_equal_unsigned,
    word_less_than_equal,
    word_less_than_unsigned,
    word_less_than,
    word_load_unsigned,
    word_load,
    word_not_equal,
    word_store,
    word_to_long_unsigned,
    word_to_long,
    word_to_float_unsigned,
    word_to_float,
};

pub const longest_reserved_word = 10;
pub const reserved_words = std.StaticStringMap(TokenType).initComptime(.{
    .{ "add", .addition },
    .{ "align", .@"align" },
    .{ "alloc", .allocate },
    .{ "and", .bitwise_and },
    .{ "b", .byte },
    .{ "blit", .blit },
    .{ "call", .call },
    .{ "cast", .cast },
    .{ "ceqd", .double_equal },
    .{ "ceql", .long_equal },
    .{ "ceqs", .single_equal },
    .{ "ceqw", .word_equal },
    .{ "cged", .double_greater_than_equal },
    .{ "cges", .single_greater_than_equal },
    .{ "cgtd", .double_greater_than },
    .{ "cgts", .single_greater_than },
    .{ "cled", .double_less_than_equal },
    .{ "cles", .single_less_than_equal },
    .{ "cltd", .double_less_than },
    .{ "clts", .single_less_than },
    .{ "cned", .double_not_equal },
    .{ "cnel", .long_not_equal },
    .{ "cnes", .single_not_equal },
    .{ "cnew", .word_not_equal },
    .{ "cod", .double_all_nan },
    .{ "common", .common },
    .{ "copy", .copy },
    .{ "cos", .single_all_nan },
    .{ "csgel", .long_greater_than_equal },
    .{ "csgew", .word_greater_than_equal },
    .{ "csgtl", .long_greater_than },
    .{ "csgtw", .word_greater_than },
    .{ "cslel", .long_less_than_equal },
    .{ "cslew", .word_less_than_equal },
    .{ "csltl", .long_less_than },
    .{ "csltw", .word_less_than },
    .{ "cugel", .long_greater_than_equal_unsigned },
    .{ "cugew", .word_greater_than_equal_unsigned },
    .{ "cugtl", .long_greater_than_unsigned },
    .{ "cugtw", .word_greater_than_unsigned },
    .{ "culel", .long_less_than_equal_unsigned },
    .{ "culew", .word_less_than_equal_unsigned },
    .{ "cultl", .long_less_than_unsigned },
    .{ "cultw", .word_less_than_unsigned },
    .{ "cuod", .double_any_nan },
    .{ "cuos", .single_any_nan },
    .{ "d", .double },
    .{ "data", .data },
    .{ "dbgfile", .debug_file },
    .{ "dbgloc", .debug_location },
    .{ "div", .divide },
    .{ "dtosi", .double_to_integer },
    .{ "dtoui", .double_to_integer_unsigned },
    .{ "env", .env },
    .{ "export", .@"export" },
    .{ "exts", .single_to_double },
    .{ "extsb", .byte_to_integer },
    .{ "extsh", .half_word_to_integer },
    .{ "extsw", .word_to_long },
    .{ "extub", .byte_to_integer_unsigned },
    .{ "extuh", .half_word_to_integer_unsigned },
    .{ "extuw", .word_to_long_unsigned },
    .{ "function", .function },
    .{ "h", .half_word },
    .{ "hlt", .halt },
    .{ "jmp", .jump },
    .{ "jnz", .jump_not_zero },
    .{ "l", .long },
    .{ "loadd", .double_load },
    .{ "loadl", .long_load },
    .{ "loads", .single_load },
    .{ "loadsb", .byte_load },
    .{ "loadsh", .half_word_load },
    .{ "loadsw", .word_load },
    .{ "loadub", .byte_load_unsigned },
    .{ "loaduh", .half_word_load_unsigned },
    .{ "loaduw", .word_load_unsigned },
    .{ "load", .any_load },
    .{ "loadw", .word_load },
    .{ "mul", .multiply },
    .{ "neg", .negate },
    .{ "or", .bitwise_or },
    .{ "phi", .phi },
    .{ "rem", .remainder },
    .{ "ret", .@"return" },
    .{ "s", .single },
    .{ "sar", .arthimetic_shift_right },
    .{ "sb", .byte },
    .{ "section", .section },
    .{ "sh", .half_word },
    .{ "shl", .shift_left },
    .{ "shr", .shift_right },
    .{ "sltof", .long_to_float },
    .{ "storeb", .byte_store },
    .{ "stored", .double_store },
    .{ "storeh", .half_word_store },
    .{ "storel", .long_store },
    .{ "stores", .single_store },
    .{ "storew", .word_store },
    .{ "stosi", .single_to_integer },
    .{ "stoui", .single_to_integer_unsigned },
    .{ "sub", .subtract },
    .{ "sw", .word },
    .{ "swtof", .word_to_float },
    .{ "thread", .thread },
    .{ "truncd", .double_to_single },
    .{ "type", .type },
    .{ "ub", .byte_unsigned },
    .{ "udiv", .divide_unsigned },
    .{ "uh", .half_word_unsigned },
    .{ "ultof", .long_to_float_unsigned },
    .{ "urem", .remainder_unsigned },
    .{ "uw", .word_unsigned },
    .{ "uwtof", .word_to_float_unsigned },
    .{ "vaarg", .vaarg },
    .{ "vastart", .vastart },
    .{ "w", .word },
    .{ "xor", .bitwise_xor },
    .{ "z", .zero },
});
